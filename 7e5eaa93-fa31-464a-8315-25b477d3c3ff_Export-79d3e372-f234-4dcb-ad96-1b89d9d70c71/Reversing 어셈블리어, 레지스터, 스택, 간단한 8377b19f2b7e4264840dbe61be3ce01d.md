# Reversing : 어셈블리어, 레지스터, 스택, 간단한 컴퓨터구조

<aside>
💡 author : agamtt(전재호) 2024-01-26

</aside>

# 컴퓨터 구조

이 내용은 “컴퓨터구조” 를 간략히 정리한 것 입니다.

컴퓨터 구조는 아주 복잡하므로, 당장은 완전히 이해하지 않아도 됩니다.

이해를 돕기 위해 간략화한 부분이 많으므로,

내용이 재미있다면, 처음부터 체계적으로 공부하기 바랍니다

[1.1.2. 컴퓨터구조 + 운영체제](https://wikidocs.net/111325)

# 레지스터(register)

컴퓨터에는 숫자를 저장할 수 있는 아주 빠른 작은 저장장치가 붙어있습니다.

이것을 레지스터(register) 라고 부릅니다.

인간이 5+7+8 을 할때, 5+7 을 먼저 계산하고 머리에 기억해두고, 기억한 12 에 8을 더합니다.

레지스터도 같은 일을 합니다.

- 레지스터는 중간계산결과 등을 저장합니다.

레지스터는 8개정도 되는데, 하나하나 이름이 붙어있습니다.

예를들어,

- ebp
- esp
- eax
- ebx
- esi

등이 있습니다.

모든 레지스터 이름에 붙는 앞글자 e 는, 대신 r 이 들어갈 수도 있습니다.

(32비트 명령어에서는 e 를 붙이고, 64비트 명령어에서는 r 이 붙습니다.)

64비트에서는 이름을 아래와 같이 부릅니다.

- rbp
- rsp
- rax
- rbx
- rsi

# 메인 메모리, 램 (RAM)

레지스터는 빠르지만 저장할 수 있는 크기가 아주 작습니다.

따라서, 레지스터보다는 느리지만 크기가 큰 메모리라는 곳에 여러가지를 저장합니다.

컴퓨터는 메모리에 저장된 것을 레지스터로 옮기고, 레지스터에 저장된 값끼리 연산하면서 작동합니다.

# 메모리 주소 (memory address)

메모리는 한칸 한칸 정보를 저장할 수 있는 부품을 아주 많이 일렬로 연결해놓은 컴퓨터 부품입니다.

메모리 각 칸을 나중에 찾을 수 있도록 번호가 붙어 있습니다.

- 마치 사물함에 번호가 있어서, 번호로 사물함을 찾을 수 있는 것과 같습니다.

이런 메모리에 붙은 번호를 메모리 주소(memory address) 라고 부릅니다.

# 메모리 구분

레지스터는 빠르지만 개수가 한정되어있고, 저장할 수 있는 크기가 작으므로, 메모리를 사용한다고 했습니다.

이때, 프로그램의 실행되는 부분의 기계어와, 프로그램이 실행중에 사용하는 값들을 저장하는 메모리 등, 메모리를 구분하여 사용합니다. 이때, 구분의 기준이 되는 곳을 메모리를 구분하는 특수한 레지스터에 저장합니다.

특수한 레지스터들은 계산할 때 값을 기억하는데에 쓰이지 않고, 메모리의 구분지점을 저장하는데 쓰입니다.

# 스택 메모리(Stack)

Stack 은 메모리를 구분한 구역 중 하나로, 프로그램이 실행하는데에 필요한 값들을 저장합니다.

앞서 말했다시피, 메모리를 구분하는데 쓰이는 특수한 레지스터들이 있습니다.

스택 메모리를 구분하는 레지스터는 ebp 와 esp 입니다.

ebp 의 bp 는 base pointer , esp 의 sp 는 stack pointer 라는 뜻입니다.

- base 는 바닥이라는 뜻 입니다.
- ebp 에는 스택이 시작되는 메모리 주소가 저장됩니다.
- esp 에는 스택이 끝나는 메모리 주소가 저장됩니다.

예를 들어, 메모리 주소와 메모리를 적어놓고 보겠습니다.

왼쪽이 메모리 주소이고, 오른쪽은 그 메모리에 저장된 숫자입니다.

```python
0001 : 뭔가 저장됨
0002 : 뭔가 저장됨
0003 : 뭔가 저장됨
0004 : 뭔가 저장됨
0005 : 뭔가 저장됨
0006 : 뭔가 저장됨
0007 : 뭔가 저장됨
...
```

이때 레지스터에 아래와 같이 저장되어있으면,

```python
esp = 0003
ebp = 0005
```

스택 메모리는 0003 부터 0005 까지 입니다.

```python
0001 : 뭔가 저장됨
0002 : 뭔가 저장됨
0003 : 뭔가 저장됨, 스택메모리 영역임
0004 : 뭔가 저장됨, 스택메모리 영역임
0005 : 뭔가 저장됨, 스택메모리 영역임
0006 : 뭔가 저장됨
0007 : 뭔가 저장됨
...
```

스택에 있는 값을 레지스터로 불러오는 등의 작업을 할때는, 이 레지스터들을 기준으로 값을 불러옵니다.

예를 들어, 아래와 같은 메모리가 있을 때, 0004 주소에 저장된 3 이라는 값을 불러오려면,

```python
esp = 0002
ebp = 0005

0001 : 뭔가 저장됨
0002 : 뭔가 저장됨, 스택메모리 영역임, 여기가 esp
0003 : 뭔가 저장됨, 스택메모리 영역임
0004 : 3, 스택메모리 영역임
0005 : 뭔가 저장됨, 스택메모리 영역임, 여기가 ebp
0006 : 뭔가 저장됨
0007 : 뭔가 저장됨
...
```

3 이 저장된 메모리의 주소는 이렇게 표현됩니다.

```python
ebp-1
또는
esp+2
```

# 어셈블리어, 기계어

어셈블리어는 기계어를 읽기 쉽게 풀어 쓴 것 입니다.

어셈블리어는 연산자와, 그 연산을 수행할 피연산자로 구성됩니다.

- 어셈블리어에서 연산자를 opcode 라고 부릅니다.
- 피연산자를 operand 라고 부릅니다.

어셈블리어는 컴퓨터에게 이런 작업을 하라고 지시합니다.

- 레지스터에 있는 값을 다른 레지스터로 복사해라
- 레지스터에 있는 값을 스택으로 옮겨라
- 스택에 있는 값을 레지스터로 복사해와라

# 어셈블리어의 작동방식

대표적으로 많이 쓰이는 어셈블리어는 아래와 같습니다.

- add
- sub
- mov
- jmp
- push

add 와 sub 는 어떤 레지스터끼리 값을 빼고 더합니다.

```bash
add eax 3 ; eax 레지스터에 저장된 값에 3을 더합니다.
sub esp 5 ; esp 레지스터에 저장된 값에 5를 뺍니다.
```

mov 는 레지스터나 스택에 저장된 값을 다른 레지스터나 스택으로 옮깁니다.

아래는 B 에 저장된 값을 A 로 옮기는 명령입니다.

```python
mov A, B
```

jmp 는 다른 명령어로 점프합니다.

- 기계어는 위에서 아래로 실행됩니다.
- 아래에서, 000000001 과 000000002 는 명령어가 메모리에 저장된 위치를 표현하는 것으로, 명령어의 주소라고 부릅니다.
- 아래 코드는 mov A B 를 실행하고, mov A B 로 점프하므로, 무한히 mov A B 가 실행됩니다.

```python
00000001 : mov A B
00000002 : jmp 00000001
00000003 : (다른 명령어들)
```

push 는 스택메모리에 어떤 값을 저장합니다.

- push 는 esp 에 1을 빼서 스택을 한칸 확장하고, 그 바로 아래에 있는 메모리에 값을 저장합니다.
- 스택 메모리의 주소를 알면, 그 값을 다시 mov 등으로 복사해서 쓸 수 있습니다.

아래 어셈블리어는 esi 레지스터에 저장된 값을 스택메모리에 넣고, 그 값을 다시 eax 에 옮깁니다.

```python
push esi
mov eax, ebp+7
```

이걸 메모리와 함께 순서대로 보면,

처음상태)

```python
esi = "Hello"
eax = 뭔가 저장됨
esp = 0002
ebp = 0005

0001 : 뭔가 저장됨
0002 : 뭔가 저장됨, 스택메모리 영역임, 여기가 esp
0003 : 뭔가 저장됨, 스택메모리 영역임
0004 : 뭔가 저장됨, 스택메모리 영역임
0005 : 뭔가 저장됨, 스택메모리 영역임, 여기가 ebp
0006 : 뭔가 저장됨
0007 : 뭔가 저장됨
...
```

실행)

```python
push esi
```

메모리와 레지스터가 변경됨  : 스택이 한칸 늘어나고, esi 의 값이 스택에 복사됨

```python
esi = "Hello"
eax = 뭔가 저장됨
esp = 0001 # 1이 감소하고 스택이 한칸 확장된다.
ebp = 0005

0001 : 뭔가 저장됨, 스택메모리 영역임, 여기가 esp
0002 : "Hello"가 저장됨, 스택메모리 영역임
0003 : 뭔가 저장됨, 스택메모리 영역임
0004 : 뭔가 저장됨, 스택메모리 영역임
0005 : 뭔가 저장됨, 스택메모리 영역임, 여기가 ebp
0006 : 뭔가 저장됨
0007 : 뭔가 저장됨
...
```

실행 : ebp 를 기준으로 스택에서 값을 찾음

```python
mov eax, ebp-3
```

메모리와 레지스터가 변경됨 : 스택에 있는 값이 eax 로 복사됨

```python
esi = "Hello"
eax = "Hello" # 스택에서 값이 불러와졌다.
esp = 0001 # 1이 감소하고 스택이 한칸 확장된다.
ebp = 0005

0001 : 뭔가 저장됨, 스택메모리 영역임, 여기가 esp
0002 : "Hello"가 저장됨, 스택메모리 영역임
0003 : 뭔가 저장됨, 스택메모리 영역임
0004 : 뭔가 저장됨, 스택메모리 영역임
0005 : 뭔가 저장됨, 스택메모리 영역임, 여기가 ebp
0006 : 뭔가 저장됨
0007 : 뭔가 저장됨
...
```

# 디버거가 도와줌

이러한 어셈블리어는 읽기 어려우므로, 디버거들은 인간이 읽기 쉽게 많이 도와줍니다.

예를 들어, 아래와 같은 코드는 ebp-3 에 있는 값을 eax 로 옮깁니다.

근데 ebp-3 메모리주소에 뭐가 저장되어있는지 찾아볼려면 불편합니다.

```python
mov eax, ebp-3
```

그래서 디버거는 자기가 ebp-3 을 찾아보고 옆에 표시해줍니다.

```python
mov eax, ebp-3 ; "Hello"
```

계속