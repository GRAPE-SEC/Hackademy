# 보호기능과 우회 소개 : Stack Guard

# 해킹과의 전쟁

하트블리드(Heartbleed), 모리스웜(Moris Worm), 이터널블루(Iternal Blue) 등, 해킹 역사에 한 획을 그은 많은 취약점들이 **메모리 취약점**을 활용하였습니다.

메모리가 손상되어서 프로그램이 부셔지는 것은  많은 사람들(**해커가 아닌**)이 원치 않는 것이였습니다.

그러나 프로그래머가 코딩할때 이걸 모두 확인하는 것은 매우 어려운데다가, **멍청한 프로그래머**나 멍청한 회사는 항상 존재하기 마련이기 때문에 골치였습니다.

게다가 복잡한 시스템(커널, 브라우저, 미디어 라이브러리 등) 을 만들때는 숙련된 프로그래머가 코딩해도 메모리 버그가 꼭 있기 마련이였습니다

![image.png](image%20163.png)

![image.png](image%20164.png)

![image.png](image%20165.png)

![image.png](image%20166.png)

그래서 사람들은 자동으로 메모리 해킹이나 버그를 감지해서 차단하는 기술을 발명해왔습니다.

하지만 완벽한 방어기술은 아직 나오지 않았으며, 공격의 난이도는 높아지지만 매년 뚫리는 사례는 계속 나오고 있습니다.

새로운 기술이 나오면 해커들은 그걸 뚫는 방법을 고안하고, 그걸 막는 방법이 나오고 그걸 계속 반복해왔습니다.

요즘 나오는 프로그램들은 많은 보안 기능을 내장하고 있습니다. 이것들을 해킹하려면 이를 뚫어야합니다.

대충 소개해보겠습니다

## Stack Guard

photoDot 에서도 보았듯, 메모리 버퍼가 초과되면 메모리값이 덮어써져서 여러가지 문제가 발생합니다.

따라서, 프로그램이 실행될 때 랜덤한 값을 버퍼 뒤에 넣어놓고, 이 값을 체크하는 방식의 보안기능이개발되었습니다.

컴파일될때 바이너리 안에 해당 기능이 포함됩니다.

Stack Guard 는 광부와 새 이야기를 따서 Stack Canary 라고도 불립니다.

자세한건 아래를 참고하세요

[https://blog.naver.com/luexr/223155451155](https://blog.naver.com/luexr/223155451155)

스택 가드는 메모리가 덮어쓰여지는 것을 막지는 않지만, 스택 가드의 비밀번호를 맞는 비밀번호와 대조하므로써 메모리가 덮어써졌는지 여부만 알 수 있습니다. 덮어써지면 그 뒤로 해킹당하지 않도록 프로그램을 꺼버리는 것이죠

## Stack Guard 우회

Stack Guard 는 메모리에 저장된 일종의 비밀번호이기 때문에, 메모리의 값을 확인하는 취약점이 추가로 있으면, 메모리를 덮어쓸때 맞는 값을 입력해서 우회할 수 있습니다.

다만 메모리 값을 노출하는 취약점을 추가로 찾아야하므로 난이도가 높아진다고 할 수 있습니다

메모리값이 노출되는 취약점을 Memory Leak 이라고 부릅니다

## NX/DEP

바이너리에다가 표시를 해서, 하드웨어나 소프트웨어에게 “여기에 있는 기계어는 기계어로 해석될지라도 실행하지마라” 라고 알려주는 류의 보안 기술입니다.

버퍼오버플로우를 비롯하여 버그가 생겨서 메모리영역으로 점프되더라도 그게 CPU 에서 실행되지 않도록 막는거죠

그러면 공격자는 실행가능한 코드를 조립하거나, 실행가능한 라이브러리 안에서 악성코드를 실행하거나, Memory Leak 을 이용하여 메모리주소를 알아내는 등 우회를 하여 공격합니다.

아니면 코드 중에 NX 없는 곳을 노리거나요

## PIE/RELRO

버그를 일으켜서 return address 를 덮어쓰기해서 코드 흐름을 조작하는 공격을 방어하기 위한 방법인데, 실행할때마다 바이너리 안의 주소가 매번 랜덤으로 바뀌도록 하는 방법입니다.

메모리 취약점을 악용하려면 실행시점에서 어디로 점프할지 알아야하는 경우가 많은데 그걸 못하게 하는거죠

예를 들어, 해커가 자기 컴퓨터에서 바이너리를 실행하면 어떤 메모리 주소에 어떤 코드가 있는지 확인할 수 있습니다. gdb 나 메모리 관련 시스템콜을 써서 확인하는거죠

근데 그걸 기준으로 악성코드를 작성하더라도 다시 실행될때는 메모리 주소가 바뀌니 무용지물이 됩니다.

 return address 를 덮어쓸 수 있게 되더라도 어디로 jump 할지 모르도록 하는거죠.

Stack Guard 와 마찬가지로 Memory Leak 이 있으면 무력화됩니다. Memory Leak 이 있으면 악성코드가 실행될때 메모리를 읽어서 점프할 곳을 알아내서 return address 를 덮어쓰도록 악성코드를 짜면 됩니다.

## 그 외

그 외에도 Data Flow Integrity 등의 기술이 새로 나오고 있습니다.

# 공격기법 : ROP (return oriented programming)

현재(2024)까지 알려진, 메모리 방어를 우회하는 기술 중 하나는 ROP 입니다.

가장 치명적인 공격은 Shellcode 가 외부에서 삽입되어서 강제로 실행되는 공격인데, (해커가 짠 코드가 맘대로 실행되니까)

그래서, Shellcode 가 삽입될만한 곳은 CPU 가 인식해서 실행하지 않도록 막는 방어기법들이 개발되었습니다.

이걸 뚫기 위한 방법이 ROP 인데, Hovav Shacham 라는 해커가

The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86) 라는 논문에서 처음 소개했다고 알려져있습니다.

Shellcode 를 실행 불가능하게 하기 위해 버퍼들을 실행 못하게 막는다고 해도, **실제로 프로그램이 작동하는 코드는 실행가능해야합니다**. (이게 실행 불가능하면 프로그램이 실행 안됨)

ROP 는 실행가능한 코드 중에 쓸만한 것들 (보통, Gadget 이라고 부르는, jump 나 return 명령을 포함하는 작은 코드) 를 아주 많이 조각 조각 모아서, 조각들끼리 점프를 해서 쉘코드를 생성합니다.

![image.png](image%20167.png)

비유하자면, 비행기에 총을 못들고 타게 했더니

비행기 안에 있는걸 잘 조립해서 총 비슷한걸 만들어내는 그런거입니다

![image.png](image%20168.png)

ROP 도 막으려고 Code Flow Gaurd , CET 같은 기술을 개발하고 있다고 하는군요

[메모리 취약점 ROP 공격 방어 방법 개발돼…공격자는 비상](https://www.dailysecu.com/news/articleView.html?idxno=14611)

## 실행 환경 보안 기술

그 외에도, 프로그램이 해킹되어서 실행흐름이 조작되어도 해당 프로그램이 나쁜짓을 못하도록 운영체제나 런타임에서 격리하는 기술이 발명되었습니다. 이것을 샌드박스(Sandbox) 라고 부릅니다.

근데 이건 아예 프로그램이 운영체제와 상호작용을 못하게 막는거니 불편을 초래할수도 있습니다.  

이미지 프로그램이 완전 샌드박스로 작동하면 저장된 이미지를 못읽는다거나 할테니 좀그렇죠

그리고 샌드박스를 탈출하여 밖에 영향을 주는 공격도 존재합니다 Sandbox Escape 라고 부릅니다.

## Heap 손상

메모리 취약점은 버퍼 오버플로우만 있는 것이 아닙니다.

malloc() 등의 함수나 new 함수는 메모리를 할당하는데, 이러한 데이터는 메모리의 힙(Heap) 영역에 저장됩니다.

Heap Overflow 나 Use After Free 포인터가 있는 경우, 메모리를 할당하는 로직을 악용할 수 있고, Heap 메모리를 조작하여 각종 취약점을 만들어 낼 수 있습니다

그런 류의 프로그램에는 커널, 브라우저 등이 있습니다.

- 실행파일에 메모리를 특수하게 할당하는 코드를 작성해서 커널의 힙을 손상시킵니다
- 브라우저에서 악의적으로 제작된 웹사이트 안의 javascript 나 webAssembly 를 이용하여 javascript 엔진이나 렌더링 엔진의 메모리를 특수하게 할당하여 힙을 손상시킵니다

자세한 것은 아래 글을 읽어보면 좋습니다.

[메모리 취약점:과거, 현재, 미래 (1) 개요: CPUU의 Daydreamin'](https://www.postype.com/@cpuu/post/3938882)

[메모리 취약점:과거, 현재, 미래 (2) NX / DEP: CPUU의 Daydreamin'](https://www.postype.com/@cpuu/post/3944558)

[메모리 취약점:과거, 현재, 미래 (3) Canaries: CPUU의 Daydreamin'](https://www.postype.com/@cpuu/post/3980627)

[메모리 취약점:과거, 현재, 미래 (4) Heap Attacks: CPUU의 Daydreamin'](https://www.postype.com/@cpuu/post/4002575)

[메모리 취약점:과거, 현재, 미래 (6) Address Space Layout Randomization (ASLR): CPUU의 Daydreamin'](https://www.postype.com/@cpuu/post/4077799)

끝